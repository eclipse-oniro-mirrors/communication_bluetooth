/*
 * Copyright (C) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!namespace("@ohos.bluetooth.connection", "connection")
@!sts_inject("""
static { loadLibrary("bluetoothConnection_taihe_native.z") }
""")
from ohos.bluetooth.constant use MajorClass, MajorMinorClass, ProfileConnectionState, ProfileId, ProfileUuids;

@!sts_inject("""
export function on(type: string, cb: (arg_0: Object) => void) {
    switch (type) {
        case "discoveryResult": return onDiscoveryResult(cb);
        case "batteryChange": return onBatteryChange(cb);
        case "bluetoothDeviceFind": return onBluetoothDeviceFind(cb);
        case "bondStateChange": return onBondStateChange(cb);
        case "pinRequired": return onPinRequired(cb);
        default: throw new Error(`Unknown type: ${type}`);
    }
}
export function off(type: string, cb?: (arg_0: Object) => void) {
    switch (type) {
        case "discoveryResult": return offDiscoveryResult(cb as (((arg_0: Array<DiscoveryResult>) => void) | undefined));
        case "batteryChange": return offBatteryChange(cb as (((arg_0: BatteryInfo) => void) | undefined));
        case "bluetoothDeviceFind": return offBluetoothDeviceFind(cb as (((arg_0: Array<String>) => void) | undefined));
        case "bondStateChange": return offBondStateChange(cb as (((arg_0: BondStateParam) => void) | undefined));
        case "pinRequired": return offPinRequired(cb as (((arg_0: PinRequiredParam) => void) | undefined));
        default: throw new Error(`Unknown type: ${type}`);
    }
}
""")
function OnDiscoveryResult(callback: (data: Array<DiscoveryResult>) => void): void;
function OffDiscoveryResult(callback: Optional<(data: Array<DiscoveryResult>) => void>): void;
function OnBatteryChange(callback: (data: BatteryInfo) => void): void;
function OffBatteryChange(callback: Optional<(data: BatteryInfo) => void>): void;
function OnBluetoothDeviceFind(callback: (data: Array<String>) => void): void;
function OffBluetoothDeviceFind(callback: Optional<(data: Array<String>) => void>): void;
function OnBondStateChange(callback: (data: BondStateParam) => void): void;
function OffBondStateChange(callback: Optional<(data: BondStateParam) => void>): void;
function OnPinRequired(callback: (data: PinRequiredParam) => void): void;
function OffPinRequired(callback: Optional<(data: PinRequiredParam) => void>): void;

enum BluetoothTransport: i32 {
    TRANSPORT_BR_EDR = 0,
    TRANSPORT_LE = 1
}

enum ScanMode: i32 {
    SCAN_MODE_NONE = 0,
    SCAN_MODE_CONNECTABLE = 1,
    SCAN_MODE_GENERAL_DISCOVERABLE = 2,
    SCAN_MODE_LIMITED_DISCOVERABLE = 3,
    SCAN_MODE_CONNECTABLE_GENERAL_DISCOVERABLE = 4,
    SCAN_MODE_CONNECTABLE_LIMITED_DISCOVERABLE = 5
}

struct DeviceClass {
    majorClass: MajorClass;
    majorMinorClass: MajorMinorClass;
    classOfDevice: i32;
}

struct DiscoveryResult {
    deviceId: String;
    rssi: i32;
    deviceName: String;
    deviceClass: DeviceClass;
}

struct PinRequiredParam {
    deviceId: String;
    pinCode: String;
    pinType: PinType;
}

enum PinType: i32 {
    PIN_TYPE_ENTER_PIN_CODE = 0,
    PIN_TYPE_ENTER_PASSKEY = 1,
    PIN_TYPE_CONFIRM_PASSKEY = 2,
    PIN_TYPE_NO_PASSKEY_CONSENT = 3,
    PIN_TYPE_NOTIFY_PASSKEY = 4,
    PIN_TYPE_DISPLAY_PIN_CODE = 5,
    PIN_TYPE_OOB_CONSENT = 6,
    PIN_TYPE_PIN_16_DIGITS = 7
}

struct BatteryInfo {
    deviceId: String;
    batteryLevel: i32;
    leftEarBatteryLevel: i32;
    leftEarChargeState: DeviceChargeState;
    rightEarBatteryLevel: i32;
    rightEarChargeState: DeviceChargeState;
    boxBatteryLevel: i32;
    boxChargeState: DeviceChargeState;
}

enum DeviceChargeState: i32 {
    DEVICE_NORMAL_CHARGE_NOT_CHARGED = 0,
    DEVICE_NORMAL_CHARGE_IN_CHARGING = 1,
    DEVICE_SUPER_CHARGE_NOT_CHARGED = 2,
    DEVICE_SUPER_CHARGE_IN_CHARGING = 3
}

enum DeviceType: i32 {
    DEVICE_TYPE_DEFAULT = 0,
    DEVICE_TYPE_CAR = 1,
    DEVICE_TYPE_HEADSET = 2,
    DEVICE_TYPE_HEARING = 3,
    DEVICE_TYPE_GLASSES = 4,
    DEVICE_TYPE_WATCH = 5,
    DEVICE_TYPE_SPEAKER = 6,
    DEVICE_TYPE_OTHERS = 7
}

struct BondStateParam {
    deviceId: String;
    state: BondState;
    cause: UnbondCause;
}

enum BondState: i32 {
    BOND_STATE_INVALID = 0,
    BOND_STATE_BONDING = 1,
    BOND_STATE_BONDED = 2
}

enum UnbondCause: i32 {
    USER_REMOVED = 0,
    REMOTE_DEVICE_DOWN = 1,
    AUTH_FAILURE = 2,
    AUTH_REJECTED = 3,
    INTERNAL_ERROR = 4
}

struct ControlDeviceActionParams {
    deviceId: String;
    type: ControlType;
    typeValue: ControlTypeValue;
    controlObject: ControlObject;
}

enum ControlType: i32 {
    PLAY = 0,
    VIBRATE = 1,
    FLASH = 2,
    LOCK = 3,
    ERASE = 4
}

enum ControlTypeValue: i32 {
    DISABLE = 0,
    ENABLE = 1,
    QUERY = 2
}

enum ControlObject: i32 {
    LEFT_EAR = 0,
    RIGHT_EAR = 1,
    LEFT_RIGHT_EAR = 2
}

struct TrustedPairedDevices {
    trustedPairedDevices: Array<TrustedPairedDevice>;
}

struct TrustedPairedDevice {
    sn: String;
    deviceType: String;
    modelId: String;
    manufactory: String;
    productId: String;
    hiLinkVersion: String;
    macAddress: String;
    serviceType: String;
    serviceId: String;
    deviceName: String;
    uuids: String;
    bluetoothClass: i32;
    token: @arraybuffer Array<u8>;
    deviceNameTime: i64;
    secureAdvertisingInfo: @arraybuffer Array<u8>;
    pairState: i32;
}

function GetRemoteProductId(deviceId: String): String;

function GetRemoteDeviceName(deviceId: String, alias: Optional<bool>): String;

function GetPairedDevices(): Array<String>;

function SetBluetoothScanMode(mode: ScanMode, duration: i32): void;

function GetRemoteDeviceClass(deviceId: String): DeviceClass;

@promise function ControlDeviceAction(controlDeviceActionParams: ControlDeviceActionParams): void;

@promise function GetLastConnectionTime(deviceId: String): i64;

@promise function GetRemoteDeviceType(deviceId: String): DeviceType;

@promise function UpdateCloudBluetoothDevice(trustedPairedDevices: TrustedPairedDevices): void;

@promise function GetRemoteDeviceBatteryInfo(deviceId: String): BatteryInfo;

@promise function SetRemoteDeviceName(deviceId: String, name: String): void;

@promise function SetRemoteDeviceType(deviceId: String, type: DeviceType): void;

function GetBluetoothScanMode(): ScanMode;

function GetProfileConnectionState(profileId: Optional<ProfileId>): ProfileConnectionState;

function GetLocalName(): String;

function GetPairState(deviceId: String): BondState;

function StartBluetoothDiscovery(): void;

function IsBluetoothDiscovering(): bool;

function StopBluetoothDiscovery(): void;

function SetDevicePairingConfirmation(deviceId: String, accept: bool): void;
